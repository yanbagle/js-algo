/*

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

Use binary search. If at any point, nums[l] < nums[r], then we found our sorted portion so then we can 
return min of min vs nums[l]. Else compute mid = l + r / 2. If our nums[mid] >= nums[l] then shift l Because
we're searching for a min. Else shift r. 
*/

const findMin = (nums) => {
  let l = 0;
  let r = nums.length - 1;
  let m;
  let min = nums[0];
  
  while (l <= r) {
    if (nums[l] < nums[r]) {
      min = Math.min(min, nums[l]);
      break;
    }
    
    m = Math.floor((l + r) / 2);
    min = Math.min(min, nums[m]);
    if (nums[m] >= nums[l]) {
      l = m + 1;
    } else {
      r = m - 1;
    }
  }
  
  return min;
}


/*******************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************/

const findMin = (nums) => {
  let min = nums[0];
  let l = 0;
  let r = nums.length - 1;
  let m;
  
  while (l <= r) {
    // e.g.
    //           L     R
    // [4, 5, 6, 0, 1, 2]
    if (nums[l] < nums[r]) { // we found the sorted portion
      min = Math.min(min, nums[l]);
      break;
    }
    
    m = Math.floor((l + r) / 2);
    min = Math.min(nums[m], min);
    
    // e.g.
    //  L      M       R
    // [4, 5, 6, 0, 1, 2]
    if (nums[m] >= nums[l]) { // search right
      // if m >= l, then move l because we're looking for a min
      l = m + 1;
    } else { // search left
      r = m - 1;
    }
  }
  
  return min;
}