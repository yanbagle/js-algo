// no chaining, no multiple promises
class Promise {
  constructor(callback) {
    this.status = "pending";
    this.value = null;
    this.onFullFilledCb = null;
    this.onRejectCb = null;

    const resolve = (value) => {
      if (this.status === "pending") {
        this.value = value;
        this.status = "fullfilled";
        this.onFullFilledCb(value); // execute the then cb
      }
    };

    const reject = (value) => {
      if (this.status === "pending") {
        this.value = value;
        this.status = "rejected";
        this.onRejectCb(value); // execute the then cb
      }
    };

    try {
      callback(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFullFilled, onReject) {
    if (this.status === "pending") {
      this.onFullFilledCb = onFullFilled;
      this.onRejectCb = onReject;
    }
    if (this.status === "fullfilled") {
      onFullFilled(this.value);
    }
    if (this.status === "rejected") {
      onReject(this.value);
    }
  }
}

// testing code
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => resolve("resolved!"), 1000);
});
p3.then(
  (res) => {
    console.log(res);
  },
  (err) => {
    console.log(err);
  }
);

// ' resolved!'

/*******************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************
 *****************************************************************************************************************************/

// testing code
const p4 = new Promise((resolve, reject) => {
  setTimeout(() => resolve("resolved!"), 1000);
});
p4.then(
  (res) => {
    console.log(res);
  },
  (err) => {
    console.log(err);
  }
);

class Promise {
  constructor(callback) {
    this.status = "pending";
    this.res = null;
    this.onSuccessCB = null;
    this.onFailedCB = null;
    this.STATUS = {
      PENDING: 0,
      FULLFILLED: 1,
      REJECTED: 2,
    };

    const resolve = (res) => {
      if (this.status === this.STATUS.PENDING) {
        this.status = this.STATUS.FULLFILLED;
        this.res = res;
        this.successCb(res);
      }
    };

    const reject = (res) => {
      if (this.status === this.STATUS.PENDING) {
        this.status = this.STATUS.FULLFILLED;
        this.res = res;
        this.onFailedCB(res);
      }
    };

    try {
      callback(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(successCb, rejectedCb) {
    if (this.status === this.STATUS.PENDING) {
      // user passes in an async cb into the promise
      this.onSuccessCB = successCb;
      this.onFailedCB = rejectedCb;
    } else if (this.status === this.STATUS.FULLFILLED) {
      // cb already finished executing
      this.onSuccessCB(this.res);
    } else if (this.status === this.STATUS.REJECTED) {
      // cb resulted in error
      this.onFailedCB(this.res);
    }
  }
}
